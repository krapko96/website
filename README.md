# kenrapko.dev — Development Document

## Vision

A personal website that feels like *you* — an ML engineer who builds real systems, not a designer who picked a template. The site should feel technical but approachable, like reading a well-documented codebase. It's a place to write long-form blog posts with interactive data visualizations, showcase projects, and give people a sense of how you think.

The site is **Python-native** — built with tools you already use daily. No context-switching into a JavaScript ecosystem you don't live in.

---

## Tech Stack

### Core Framework: FastHTML

[FastHTML](https://fastht.ml) is the recommendation over Flask/Django for this use case. It's a newer Python framework purpose-built for building full-stack web apps in pure Python — no templates, no Jinja, no JS build step. You write Python functions that return HTML components. It's built by the Answer.ai team (Jeremy Howard) and is designed for ML practitioners who want to build web UIs without leaving Python.

**Why FastHTML over Flask/Django:**
- Components are Python functions — feels like writing code, not markup
- HTMX is built in — interactive UI without writing JavaScript
- No template language to learn
- Lightweight, fast, deploys easily
- Aligns with who you are: an engineer who builds with Python

**Alternative if you want something more established:** Flask + Jinja2 + HTMX. Battle-tested, larger community, but more boilerplate.

### Blog Content: Markdown files with frontmatter

Write blog posts in `.md` files. Parse with `python-markdown` + `pymdown-extensions`. Frontmatter (title, date, tags, description) parsed with `python-frontmatter`. Posts live in a `/content/blog/` directory — no database needed.

### Interactive Visualizations: Plotly + Observable/D3 via HTMX islands

This is the key differentiator. Two approaches, both Python-first:

1. **Plotly** — for data-driven charts (treemaps, scatter plots, time series). You create figures in Python, render them as interactive HTML. Zero JavaScript required on your part.
2. **Embedded Observable notebooks or D3** — for more custom/editorial visualizations. Embed via iframe or HTMX partial. You can also use PyScript or Pyodide to run Python *in the browser* for truly interactive compute-on-the-page experiences.
3. **Streamlit embeds** — for heavier interactive tools (model demos, data explorers). Host as separate lightweight apps, embed in blog posts via iframe.

### Styling: PicoCSS or SimpleCSS + custom overrides

Classless CSS frameworks that look clean out of the box without requiring you to become a CSS expert. Add a small custom stylesheet for your personal brand (colors, fonts, spacing tweaks).

### Deployment: Vercel

Vercel deploys Python apps via serverless functions. Your FastHTML app runs as a single serverless function behind Vercel's edge network — fast globally, free tier is generous, and deploys automatically on every push to `main`.

**How it works with FastHTML:**
- Your `app.py` is wrapped as a Vercel serverless function in `api/index.py`
- Vercel routes all requests to this function via `vercel.json` rewrites
- Static assets (CSS, images, data files) are served directly from Vercel's CDN via the `static/` directory — no function invocation needed
- Preview deployments on every PR, production deploy on merge to `main`

**Vercel-specific constraints to keep in mind:**
- Serverless functions have a 10s timeout on the free tier (250s on Pro) — fine for serving pages, but long-running viz generation should be pre-built at deploy time
- Function payload limit is 4.5MB — pre-render heavy Plotly charts to static HTML during the build step rather than generating on every request
- No persistent filesystem — all content (Markdown, YAML, data files) must be bundled with the deployment, which is the default behavior for file-based content. Dependencies are installed from the `requirements.txt` generated by `uv export` at build time.
- Cold starts add ~200-500ms on first request after idle — acceptable for a personal site

**Custom domain:** Add `kenrapko.dev` in Vercel dashboard → Settings → Domains. Point your DNS A/CNAME records to Vercel. HTTPS is automatic.

---

## Site Architecture

```
kenrapko.dev/
├── api/
│   └── index.py              # Vercel serverless entry point — wraps app.py
├── app.py                    # FastHTML app — routes and page composition
├── build.py                  # Pre-render script: generates static viz HTML at deploy time
├── components/
│   ├── layout.py             # Base page shell (head, nav, footer)
│   ├── blog.py               # Blog list, post rendering, tag filtering
│   ├── projects.py           # Project cards
│   └── viz.py                # Visualization embedding helpers
├── content/
│   ├── blog/
│   │   ├── 2026-02-10-kalshi-prediction-markets.md
│   │   ├── 2026-01-15-cfr-algorithms-in-practice.md
│   │   └── ...
│   └── projects/
│       ├── lcht.yaml
│       ├── baseball-predictions.yaml
│       └── monce-tracking.yaml
├── static/
│   ├── css/
│   │   └── style.css
│   ├── images/
│   └── data/                 # JSON/CSV datasets for visualizations
├── visualizations/
│   ├── _rendered/            # Pre-built viz HTML (generated by build.py)
│   ├── kalshi_treemap.py     # Plotly figure generators
│   ├── pitcher_model.py
│   └── ...
├── vercel.json               # Vercel routing and build config
├── pyproject.toml            # Project metadata and dependencies (managed by uv)
├── uv.lock                   # Locked dependency versions (commit this)
├── .python-version           # Python version pin for uv (e.g., "3.12")
├── .gitignore                # Include: .venv/, requirements.txt, visualizations/_rendered/
└── README.md
```

---

## Pages

### 1. Home (`/`)

Not a generic landing page. Something that immediately signals who you are.

**Concept — "The Terminal"**: The landing page subtly resembles a terminal or IDE. A brief introduction rendered as if it's a docstring or README. Links to blog, projects, and about feel like navigating a file tree. This isn't a gimmick — it's a visual language that says "I'm an engineer" without explicitly saying it.

```
$ whoami
Ken Rapko — Sr. AI/ML Engineer

$ cat interests.txt
prediction markets · computer vision · ML systems
sports analytics · counter-factual reasoning

$ ls ./recent
→ blog/kalshi-prediction-markets.md
→ blog/cfr-algorithms-in-practice.md
→ projects/lcht-agent-platform.md
```

Keep it minimal. No hero image, no "Welcome to my website." Just you.

### 2. Blog (`/blog`)

A reverse-chronological list of posts with:
- Title, date, estimated reading time
- 1-2 sentence description
- Tags (filterable): `ml-systems`, `sports-analytics`, `prediction-markets`, `computer-vision`, `career`

Each post supports:
- Markdown rendering with syntax highlighting (via Pygments or highlight.js)
- Embedded Plotly charts (rendered server-side, interactive client-side)
- LaTeX math rendering (KaTeX, loaded only on posts that need it)
- Code blocks with copy button

### 3. Projects (`/projects`)

A curated grid of projects with:
- Short description
- Tech stack tags
- Link to GitHub / live demo / paper
- Status indicator (active, archived, published)

Featured projects based on your resume:
- **LCHT Agent Platform** — data science agent for anti-human trafficking
- **Baseball Prediction Models** — pitcher and NCAA tournament predictions
- **MONCE Metrics** — visual object tracking (link to arXiv paper)
- **Kalshi Market Analysis** — prediction market data visualizations (this becomes a blog series *and* a project)

### 4. About (`/about`)

Brief bio, professional timeline (not a resume dump — link to resume PDF for that). What you're interested in, what you're working on, how to reach you.

Include a lightweight professional timeline:
```
Virginia Tech → Lockheed Martin → Georgia Tech (MS) → Nike → Now
  ME/Robotics    CV/ML/R&D       Comp. Perception    AI/ML
```

### 5. Resume (`/resume`)

Serve the PDF directly, plus an HTML-rendered version for SEO and accessibility.

---

## Blog Post Format

Each post is a Markdown file with YAML frontmatter:

```markdown
---
title: "What Kalshi's Volume Data Tells Us About Prediction Markets"
date: 2026-02-10
tags: [prediction-markets, data-viz]
description: "Sports betting dwarfs everything else. Here's the breakdown."
draft: false
viz:
  - kalshi_treemap
  - volume_timeseries
---

The prediction market landscape on Kalshi is dominated by one category...

{{viz:kalshi_treemap}}

The treemap above shows total notional volume by market category...
```

The `viz` frontmatter declares which visualization modules to load. The `{{viz:name}}` placeholder gets replaced at render time with the corresponding Plotly figure or interactive component.

---

## Visualization System

This is what makes the site special. Each visualization is a Python function that returns a Plotly figure or HTML fragment.

```python
# visualizations/kalshi_treemap.py

import plotly.express as px

def render():
    data = {
        "Category": ["Sports", "Politics", "Crypto", "Finance", "Weather"],
        "Volume_B": [13.18, 2.45, 0.84, 0.76, 0.30],
    }
    fig = px.treemap(
        data,
        path=["Category"],
        values="Volume_B",
        color="Category",
    )
    fig.update_layout(margin=dict(t=30, l=0, r=0, b=0))
    return fig.to_html(include_plotlyjs="cdn", full_html=False)
```

When a blog post references `{{viz:kalshi_treemap}}`, the rendering pipeline:
1. At **build time** (`build.py` runs during Vercel's build step): imports `visualizations/kalshi_treemap`, calls `render()`, writes the HTML to `visualizations/_rendered/kalshi_treemap.html`
2. At **request time**: the blog renderer reads the pre-built HTML from `_rendered/` and injects it into the post

Pre-rendering is important for Vercel's serverless model — it avoids importing Plotly (a heavy library) on every request, keeps function cold starts fast, and stays well within the response payload limits.

This means your visualizations are **version-controlled Python code** that lives next to your prose. You push an update to the data, Vercel rebuilds, and the blog post updates automatically.

---

## Design Principles

### Visual Identity

- **Color palette**: Dark background optional (you work in terminals and IDEs), but a clean light theme is more readable for long-form blog content. Consider a toggle.
- **Typography**: Monospace for code and the terminal-style landing page. A clean serif or sans-serif (Inter, IBM Plex Sans, or Merriweather) for prose.
- **Accent color**: Pick one. Something from the Plotly default palette ties your visualizations to your brand — the blue from that Kalshi treemap (`#4285f4`) would work well.
- **Minimal chrome**: No sidebars, no widgets, no clutter. Navigation is a simple top bar: `Blog | Projects | About`

### Voice

Your blog posts should read like you're explaining something to a smart colleague — technical but not academic, opinionated but backed by evidence. Think of the tone in your resume bullets: direct, specific, results-oriented. Bring that energy to long-form writing.

Topics that play to your strengths:
- ML systems in production (the gap between notebooks and deployed models)
- Prediction markets and sports analytics
- Computer vision and tracking metrics
- Engineering culture and career growth (3 promotions in 5 years is a story worth telling)
- Counter-factual reasoning and game theory

---

## Implementation Phases

### Phase 1: Foundation (Week 1-2)
- [ ] Set up FastHTML project with basic routing
- [ ] Implement layout component (nav, footer, meta tags)
- [ ] Markdown blog rendering pipeline (frontmatter + content)
- [ ] Static file serving (CSS, images)
- [ ] Create `api/index.py` entry point and `vercel.json` config
- [ ] Deploy to Vercel, connect custom domain
- [ ] Migrate any existing content from GitHub Pages

### Phase 2: Content & Visualization (Week 3-4)
- [ ] Build visualization system (Plotly figure injection)
- [ ] Create `build.py` to pre-render visualizations during Vercel build step
- [ ] Write 2-3 launch blog posts
- [ ] Create project cards with data from YAML files
- [ ] Add syntax highlighting and code copy buttons
- [ ] RSS feed (`/feed.xml`)

### Phase 3: Polish (Week 5-6)
- [ ] Terminal-style landing page
- [ ] Dark/light mode toggle
- [ ] SEO meta tags and Open Graph images
- [ ] Analytics (Vercel Analytics built-in, or Plausible/Umami for privacy-respecting self-hosted)
- [ ] Reading time estimates and table of contents for long posts

### Phase 4: Advanced (Ongoing)
- [ ] LaTeX math rendering for technical posts
- [ ] Streamlit embeds for interactive model demos (host on Streamlit Community Cloud, embed via iframe — Vercel can't run long-lived Streamlit processes)
- [ ] Search functionality (client-side with lunr.js or Pagefind — better fit than server-side for serverless)
- [ ] Email newsletter integration (Buttondown)
- [ ] Comment system (giscus — GitHub Discussions backed)

---

## Launch Blog Post Ideas

1. **"What Kalshi's Volume Data Tells Us About Prediction Markets"** — the visualization from your screenshot, with analysis
2. **"From Mechanical Engineer to ML Engineer: A Non-Linear Career Path"** — VT → Lockheed → GT → Nike
3. **"Counter-Factual Regret Minimization: From Poker AI to Enterprise"** — the R&D project you pitched and won funding for
4. **"Building a Python-Native Personal Website (and Why I Didn't Use React)"** — meta post about this very site
5. **"Productionizing ML at Scale: Lessons from 45 Million BOM Line Items"** — war stories from Nike

---

## Quick Start

```bash
# Install uv (if not already installed)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Create project
mkdir kenrapko.dev && cd kenrapko.dev
uv init

# Add dependencies
uv add python-fasthtml python-markdown python-frontmatter
uv add plotly pymdown-extensions pygments
```

### Vercel Setup

**`api/index.py`** — the serverless entry point that wraps your FastHTML app:

```python
from app import app

# Vercel expects a handler; FastHTML exposes an ASGI app
handler = app
```

**`vercel.json`** — routes all traffic through your function, serves static files from CDN:

```json
{
  "builds": [
    { "src": "api/index.py", "use": "@vercel/python" },
    { "src": "static/**", "use": "@vercel/static" }
  ],
  "routes": [
    { "src": "/static/(.*)", "dest": "/static/$1" },
    { "src": "/(.*)", "dest": "/api/index.py" }
  ],
  "buildCommand": "curl -LsSf https://astral.sh/uv/install.sh | sh && uv export > requirements.txt && uv run python build.py"
}
```

**Why the build command works this way:** Vercel's Python runtime expects a `requirements.txt` to install dependencies. Rather than maintaining one manually, `uv export` generates it from your lockfile at build time. This keeps `uv.lock` as your single source of truth. The `requirements.txt` is ephemeral — generated during the build, never committed.

**Local development:**

```bash
# Run the dev server
uv run python app.py

# Add a new dependency
uv add some-package

# Run the build script locally to test viz pre-rendering
uv run python build.py
```

**Deploy:**

```bash
# Install Vercel CLI
npm i -g vercel

# First deploy (links to your Vercel account + creates project)
vercel

# Production deploy
vercel --prod

# After this, connect your GitHub repo in the Vercel dashboard
# for automatic deploys on push to main
```

**Environment notes:**
- Vercel uses Python 3.12 by default. Pin your version in `pyproject.toml` with `requires-python = ">=3.12"` and in `vercel.json` with `"runtime": "python3.12"` if needed.
- `uv.lock` should always be committed — it ensures reproducible builds across local dev and Vercel.
- `requirements.txt` is generated at build time by `uv export` and should be in `.gitignore`.
- `build.py` runs during `buildCommand` — this is where you pre-render Plotly charts so they don't need to be generated on every request.
- Vercel's free tier gives you 100GB bandwidth/month and unlimited deploys — more than enough for a personal site.

---

*This document is a living spec. Update it as the site evolves.*